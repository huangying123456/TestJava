---
title: Java Concurrency in Practice
date: 2017-10-23 13:18:00
## 摘要
Note For Java Concurrency in Practice
<!--more-->

# 第一章 简介
## 为什么要并发
- 资源利用率
- 公平性
- 便利性
## 线程的优势
如果使用得当，线程可以有效的降低程序的开发和维护成本，同时提升复杂应用程序的性能。线程能够将大部分的异步工作流转换成串行工作流，因此能更好的模拟人类的工作方式和交互方式。此外，线程还可以降低代码的复杂度，使代码更容易编写、阅读和维护。
- 发挥多处理器的强大能力
- 建模的简单性
- 异步事件的简化处理
- 响应更灵敏的用户界面
## 线程带来的风险
- 安全性问题（代码重排之类的操作造成的同步问题）
- 活跃性问题（死锁，活锁，饥饿等问题）
- 性能问题
# 第二章 线程安全性
## 什么是线程安全性
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。
## 原子性
### 竞态条件：在并发编程中，由于不恰当的执行时序而出现不正确的结果
### 复合操作：非原子性的操作
在实际情况中，应尽可能的使用现有的线程安全对象（例如AcomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转化情况要更为容易，从而也更容易维护和验证线程安全性。
## 加锁机制
要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。
### 内置锁：synchronized
## 用锁来保护状态
#### 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的
#### 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁
#### 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要有一个锁来保护
## 活跃性与性能
#### 通常，在简单性与性能之间存在着相互制约的因素。当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性（这可能会破坏安全性）
#### 当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁
# 第三章 对象的共享
## 可见性
在没有处理同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，想要对内存操作的执行顺序进行判断，几乎无法得出正确结论。
### 失效数据
### 非64位的原子操作
### 加锁与可见性
加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的县城都必须在同一个锁上同步。
### volatile变量
#### 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么久不许哟啊使用volatile变量。volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的生命周期事件的发生（例如，初始化或关闭）
#### 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性
## 发布与逸出
### 发布一个对象：使对象能够在当前作用域之外的代码中使用
### 逸出：当某个不应该发布的对象被发布
不要在构造过程中使this引用逸出。
## 线程封闭
### Ad-hoc线程封闭
维护线程封闭性的职责完全由程序实现来承担，是一种非常脆弱的封闭。
### 栈封闭
栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。
### ThreadLocal类
维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。
## 不变性
#### 不可变对象一定是线程安全的
#### 当满足以下条件时，对象才是不可变的：
- 对象创建以后其状态就不能修改
- 对象的所有域都是final类型
- 对象是正确创建的（在对象的创建期间，this引用没有逸出）
### final域
正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。
## 安全发布
### 不正确的发布：正确的对象被破坏
### 不可变对象与初始化安全性
任何线程都可以在不需要额外同步的情况下安全的访问不可变对象，即使在发布这些对象时没有使用同步。
### 安全发布的常用模式
要安全的发布一个对啊ing，对象的引用以及对象的状态必须同时对其他线程课件。一个正确构造的对象可以通过以下方式来安全的发布：
- 在静态初始化函数中初始化一个对象引用
- 将对象的引用保存到volatile类型的域或者AtomicReferance对象中
- 将对象的引用保存到某个正确构造对象的final类型域中
- 将对象的引用保存到一个由锁保护的域中
### 事实不可变对象（技术上可变，但发布后实际上不会改变）
在没有额外的同步的情况下，任何线程都可以安全的使用被安全发布的事实不可变对象。
### 可变对象
对象的发布需求取决于它的可变性：
- 不可变对象可以通过任意机制来发布
- 事实不可变对象必须通过安全方式来发布
- 可变对象必须通过安全方式来发布，而且必须是线程安全的或者由某个锁保护起来
#### 在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
**线程封闭。**线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
**只读共享。**在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
**线程安全共享。**线程安全的对象在其内部实现同步，因此多个线程可以通过对象的共有借口来进行访问而不偶要进一步的同步。
**保护对象。**被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。
# 第四章 对象的组合
## 设计线程安全的类
在设计线程安全的类的过程中，需要包含以下是哪个基本要素：
- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件
- 建立对象状态的并发访问管理策略
### 收集同步需求
如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助原子性与封装性。
### 依赖状态的操作
### 状态的所有权
## 实例封闭
#### 将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁
#### 封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无序检查整个程序
### Java监视器模式（锁）
## 线程安全性的委托（委托给工具类）
### 独立的状态变量
### 当委托失效时
如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效转台转换，那么可以将线程安全性委托给底层的状态变量。
### 发布底层的状态变量
如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全的发布这个变量。
## 在现有的线程安全类中添加功能
### 客户端加锁机制
### 组合
## 将同步策略文档化
在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。
# 第五章 基础构建模块
## 同步容器类
包括Vector，HashTable
### 同步容器类的问题（仍无法保证避免竞态条件——同时的getLast和delete）
### 迭代器与ConcurrentModificationExcaption
### 隐藏迭代器
正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。
## 并发容器
### ConcurrentHashMap
### 额外的原子Map操作
### CopyOnWriteArrayList
## 阻塞队列和生产者-消费者模式
在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，是应用程序在负荷过载的情况下变得更加健壮。
### 串行线程封闭
### 双端队列与工作密取
## 阻塞方法与中断方法
对于由于中断导致的InterruptedException来说，可以**传递InterruptedException**或者**恢复中断**。
## 同步工具类
### 闭锁（一种实现类为CountDownLatch）
闭锁是一种工具类，可以延迟线程的进度知道其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程可以通过；当到达结束状态时，这扇门会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动指导其他活动都完成后才继续执行。
### FutureTask（带有任务执行状态和返回值的Thread）
### 信号量（一种实现类为Semaphore）
计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。
### 栅栏（一种实现类为CyclicBarrier）
栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有县城必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。栅栏可以反复生效。
## 构建高效且可伸缩的结果缓存
# 第一部分小结
## 可变状态是至关重要的
所有的并发问题都可以归结为如何协调对并发状态的访问。可变状态越少，就越容易确保线程安全性。
## 尽量将域声明为final类型，除非需要他们是可变的。
## 不可变对象一定是线程安全的
不可变对象能极大的降低并发编程的复杂性。它们更为简单而且安全，可以任意共享而无须使用加锁或保护性复制等机制
## 封装有助于管理复杂性
在编写线程安全的程序时，虽然可以将所有数据都般存在全局变量中，但为什么要这样做？将数据封装在对象中，更易于维持不变性条件：将同步机制封装在对象中，更易于遵循同步策略。
## 用锁来保护每个可变对象
## 当保护同一个不变性条件中的所有变量时，要使用同一个锁
## 在执行复合操作期间，要持有锁
## 如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题
## 不要故作聪明的推断出不需要使用同步
## 在设计过程中考虑线程安全，或者在文档中明确的之处他不是线程安全的
## 将同步策略文档化
# 第六章 任务执行
大多数并发应用程序都是围绕“”任务执行来构建的：任务通常是一些抽象的且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。
## 在线程中执行任务
### 串行的执行任务
### 显式的为任务创建线程
### 无限制的创建线程的不足
- 线程生命周期的开销非常高
- 资源消耗
- 稳定性
## Executor框架（基于生产者-消费者模式）
### 执行策略
- 在什么（what）线程中执行任务？
- 任务按照什么（what）顺序执行（FIFO，LIFO，优先级）？
- 有多少个（how many）任务能并发执行？
- 在队列中有多少个（how many）任务在等待执行？
- 如果系统由于过载而需要拒绝一个任务，那么它应该选择哪一个（which）任务？另外，如何（how）通知应用程序有任务被拒绝？
- 在执行一个任务之前或之后，应该进行那些（what）动作？
### 线程池
- **newFixedThreadPool**。将创建一个固定长度的线程池。每当提交一个任务时就创建一个线程，知道达到线程池的最大数量，这是线程池的规模将不再变化（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程）。
- **newCachedThreadPool**。将创建一个可缓存的线程池。如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程；当需求增加时，，则可以添加新的线程，线程池的规模不存在任何限制。
- **newSingleThreadExecutor**。是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。它能确保依照任务在队列里的顺序来串行执行。
- **newScheduledThreadPool**。创建了一个固定长度的线程池。而且以延迟或定时的方式来执行任务，类似于Timer。
### Executor的生命周期（运行，关闭和已终止）
### 延迟任务与周期任务
Timer和TimerTask中存在一些缺陷，导致其因为异常或耗时工作将带来极大的不可靠性，建议使用ScheduledThreadPool来进行延时任务与周期任务。
## 找出可利用的并行性
### 携带结果的callable与future
### 在异构任务并行化中存在的局限
当并行化异构任务时，并行取得的性能提升和异构任务中耗时最长的任务密切相关。
只有当大量相互独立切同构的任务可以并发进行处理时，才能体现出将程序的工作负载分配到多个任务重带来的真正性能提升。
### CompletionService：Executor与BlockingQueue
### 为任务设置时限
## 小结
通过围绕任务执行来设计程序，可以简化开发过程，并有助于实现并发。Executor框架将任务提交与执行策略解耦开来，同时还支持多种不同类型的执行策略。当需要创建线程来执行任务时，可以考虑使用Executor。要想在应用程序分解为不同的任务时获得最大的好处，必须定义清晰地任务边界。某些应用程序中存在着比较明显的任务边界，而在其他的一些程序中则需要进一步分析才能揭示出粒度更细的并行性。
# 第七章 取消与关闭
## 任务取消
- 用户请求取消
- 有时间限制的操作
- 应用程序事件（其他线程找到了答案，当前线程需要关闭）
- 错误
- 关闭（程序或服务器）
### 中断（在Java中并不提供抢占式中断机制）
#### 在Java的API或语言规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消之外的其他操作中使用中断，那么都是不合适的，并且很难支撑起更大的应用
#### 调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息
#### 通常，中断是实现取消的最合理方式
### 中断策略
由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。
### 响应中断
只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。
### 通过Future来实现取消
当Future.get抛出InterruptedException或TimeoutException时，如果你知道不再需要结果，那么就可以调用Future.cancel来取消任务。
### 处理不可中断的阻塞
#### 线程阻塞的原因
- Java.io包中的同步SocketI/O
- Java.io包中的同步I/O
- Selector的异步I/O
- 获取某个锁
### 采用newTaskFor来封装非标准的取消（Java 6 在TheadPoolExecutor中的新增功能）
## 停止基于线程的服务
对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法
### 关闭ExecutorService
### “毒丸”对象（得到这个对象，立即停止）
### shutdownNow的局限性（不知道调用时各个任务的状态）
## 处理非正常的线程终止
在运行时间较长的应用程序中，通常会为所有线程的未捕获异常指定同一个异常处理器，并且该处理器至少会将异常信息记录到日志中。
## JVM关闭
### 关闭钩子
### 守护线程
线程可分为两种：普通线程和守护线程。在JVM启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程。当创建一个新线程时，新线程将继承它的线程守护状态。
普通线程和守护线程之间的差异仅在于当线程退出是发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。当JVM停止时，所有仍然存在的守护线程都将被抛弃——既不会执行finally代码块，也不会执行回卷栈，而是直接退出。
**尽可能少的使用守护线程**
#### 此外，守护线程通常不能用来替代应用管理程序中各个服务的生命周期
### 终结器（finalize）
避免使用终结器
## 小结
在任务、线程、服务以及应用程序等模块中的生命周期结束问题，可能会增加它们在设计和实现时的复杂性。Java并没有提供某种抢占式的机制来取消操作或者终结线程。相反，它提供了一种协作式的中断机制来实现取消操作，但这要依赖于如何构建取消操作的协议，以及能否始终遵循这些协议。通过使用FutureTask和Executor框架，可以帮助我们构建可取消的任务和服务。
# 第八章 线程池的使用
## 在任务与执行策略之间的隐性耦合
- 依赖性任务
- 使用线程封闭机制的任务
- 对响应时间敏感的任务
- 使用ThreadLocal的任务
#### 在一些任务汇总，需要拥有或排除某种特定的执行策略。如果某些人物依赖于其他的任务，那么会要求线程池足够大，从而确保它们以来任务不会被放入等待队列中或被拒绝，而采用线程封闭机制的任务需要串行执行。通过将这些需求写入文档，将来的代码维护人员就不会由于使用了某种不合适的执行策略而破坏安全性或活跃性
### 线程饥饿死锁（AB BA）
每当提交了一个有依赖性的Executor任务时，要清楚的知道可能会出现的线程“饥饿”死锁，因此需要在代码或配置Executor的配置文件中记录线程池的大小限制或配置限制。
### 运行时间较长的任务
## 设置线程池的大小
## 配置ThreadPoolExecutor
### 线程的创建与销毁
### 管理队列任务（无界队列、有界队列和同步移交）
#### 对于Executor，newCachedThreadPool工厂方法是一种很好的默认选择，它能提供比固定大小的线程池更好的排队性能。当需要限制当前任务的数量以满足资源管理需求时，那么可以选择固定大小的线程池，就像在接受网络客户请求的服务器应用程序中，如果不进行限制，那么很容易发生过载问题
只有当任务相互独立时，为线程池或工作队列设置界限才是合理的。如果任务之间存在依赖性，那么有界的线程池或队列就可能导致线程“饥饿”死锁问题。此时应该使用无界的线程池，例如newCachedThreadPool。
### 饱和策略
- 终止
- 调用者运行
### 线程工厂
### 在构造函数后再定制ThreadPoolExecutor
## 扩展ThreadPoolExecutor
## 递归算法的并行化
## 小结
对于并发执行的任务，Executor框架是一种强大且灵活的框架。它提供了大量可调节的选项，例如创建线程和关闭线程的策略，处理队列任务的策略，并且提供了几个钩子方法来扩展它的行为。然而，与大多数功能强大的框架一样，其中有些设置参数并不能很好地工作，某些类型的任务需要特定的执行策略，而一些参数组合则可能产生奇怪的结果。
# 第九章 图形界面应用程序
## 为什么GUI是单线程的（冒泡事件太...）
### 串行事件处理
### Swing中的线程封闭机制
Swing的单线程规则是：Swing中的组件以及模型只能在这个事件分发线程中进行创建、修改以及查询。
## 短时间的GUI任务
## 长时间的GUI任务
### 取消
### 进度标识和完成标识
### SwingWorker
## 数据共享模型
### 线程安全的数据模型
### 分解数据模型（MVC分三个，在事件线程中交互）
如果一个数据模型必须被多个子线程共享，而且由于阻塞、一致性或复杂度等原因而无法实现一个线程安全的模型时，可以考虑使用分解模型设计。
## 其他形式的单线程子系统
## 小结
所有GUI框架基本上都实现为单线程的子系统，其中所有与表现相关的代码都作为任务在事件线程中运行。由于只有一个事件线程，因此运行时间较长的任务会降低GUI程序的响应性，所有应该放在后台线程中运行。在一些辅助类（例如SwingWorker）中提供了对取消、进度指示以及完成指示的支持，因此对于执行时间较长的任务来说，无论在任务中包含了GUI组件还是非GUI组件，在开发时都可以得到简化。
# 第十章 避免活跃性危险
## 死锁
### 锁顺序死锁（获取锁顺序：AB BA）
如果所有线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题。
### 动态的锁顺序死锁（A向B汇款，同时B向A汇款，锁顺序一致但对象调换，导致死锁）
### 在协作对象之间发生的死锁
如果在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能会获取其他锁（这可能会产生死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。
### 开放调用（调用方法时不需要持有锁）
在程序应尽量使用开放调用。与那些在持有锁时调用外部方法的程序相比，更易于对依赖于开放调用的程序进行死锁分析。
### 资源死锁
- 一个线程拿着数据库连接等redis连接，另一个线程拿着redis的连接等数据库连接
- 饥饿死锁：在单线程Executor中正在执行的任务依赖于之后执行的任务
## 死锁的避免与诊断
### 支持定时的锁
### 通过线程转储信息来分析锁
## 其他活跃性问题
### 饥饿
当线程由于无法访问它所需要的资源而不能继续执行时，就发生了饥饿。引发饥饿最常见的资源就是CPU的时钟周期。如果在Java应用程序中对线程的优先级使用不当，或者在持有锁时执行一些无法结束的结构，那么也可能导致饥饿。
#### 要避免使用线程优先级，因为这会增加平台依赖性，并可能导致活跃性问题。在大多数并发应用程序中，都可以使用默认的线程优先级
### 糟糕的响应性
### 活锁
线程不断执行相同的动作，并一直失败
- 失败后进入队列头，并一直失败
- 两个人让路，一直在一列
## 小结
活跃性故障是一个非常严重的问题，因为当出现活跃性故障时，除了终止应用程序之外诶有其他任何机制可以帮助从这种故障中恢复过来。最常见的活跃性故障就是锁顺序死锁。在设计时应该避免产生锁顺序死锁：确保线程在获取多个锁时采用一致的顺序。最好的解决方法是在程序中始终使用开放调用。这将大大减少需要同时持有多个锁的地方，也更容易发现这些地方。
# 第十一章 性能与可伸缩性
## 对性能的思考
### 性能与可伸缩性
可伸缩性指的是：但增加计算资源时（例如CPU、内存、存储容量或I/O带宽），程序的吞吐量或者处理能力相应的增加。
### 评估各种性能权衡因素
#### 避免不成熟的优化。首先使程序正确，然后再提高运行速度——如果它还运行的不够快
- “更快”的含义是什么？
- 该方法在什么条件下运行的更快？在低负载还是在高负载的情况下？大数据集还是小数据集？能否通过测试结果来验证你的答案？
- 这些条件在运行环境中的发生概率？能否通过测试结果来验证你的答案？
- 在其他不同条件的环境中的能否使用这里的代码？
- 在实现这种性能提升时需要付出哪些隐含的代价，例如增加开发风险或者维护开销？这种权衡是否合适？
#### 以测试为基准，不要猜测
## Amdahl定律
代码中串行化的部分决定了将代码并行化后最大的加速比
#### 在所有并发程序中都包含一些串行部分。如果你认为在你的程序中不存在串行部分，那么可以再仔细检查一遍
### Amdahl定律的应用
## 线程引入的开销
### 上下文切换
### 内存同步
不要过度担心竞争同步带来的开销。这个基本的机制已经非常快了，并且JVM还能进行额外的优化以进一步降低或消除开销。因此，我们应该将优化重点放在那些发生所竞争的地方。
### 阻塞
## 减少锁的竞争
#### 在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁
有三种方式可以降低锁的竞争程度：
- 减少锁的持有时间
- 降低锁的请求概率
- 使用带有协调机制的独占锁，这些机制允许更高的并发性
### 减小锁的范围（快进快出）
### 减小锁的粒度（将大锁分解成多个独立的小锁）
### 锁分段（同步hashmap的那种锁）
### 避免热点域
### 一些代替独占锁的方法
- ReadWriteLock
- 原子变量
### 检测CPU的利用率
如果CPU没有充分利用，可能由于以下的原因：
- 负载不充足
- I/O密集
- 外部限制
- 锁竞争
#### 通常，对象分配操作的开销比同步的开销更低
## 减少上下文切换的开销
## 小结
由于使用线程常常是为了充分利用多个处理器的计算能力，因此在并发程序性能的讨论中，通常更多的将侧重点放在吞吐量和可伸缩性上，而不是服务时间。Amdahl定律告诉我们，程序的可伸缩性取决于在所有代码中必须被串行执行的代码比例。因为Java程序中串行操作的主要来源是独占方式的资源锁，因此通常可以通过以下方式来提升可伸缩性：减小锁的持有时间，降低锁的粒度，以及采用非独占的锁或非阻塞的锁来代替独占锁。
# 第十二章 并发程序的测试
- **吞吐量**：指一组并发任务中已完成任务所占的比例
- **响应性**：指请求从出发到完成之间的时间（也成为延迟）
- **可伸缩性**：指在增加更多资源的情况下（通常指CPU），吞吐量（或者缓解短缺）的提升情况
## 正确性测试
### 基本的单元测试
### 对阻塞操作的测试
### 安全性测试
#### 在构建对并发类的安全性测试中，需要解决的关键问题在于，要找出那些容易检查的属性，这些属性在发生错误的情况下极有可能失败，同时又不会使得错误检查代码人为的限制并发性。理想情况是，在测试属性中不需要任何同步机制
#### 这些测试应该放在多处理器的系统上运行，从而进一步测试更多形式的交替运行。然而，CPU的数量越多不一定会使测试越高效。要最大程度的检测出一些对执行时序敏感的数据竞争，那么测试中线程的数量应该多于CPU的数量，这样在任意时刻都会有一些线程在运行，而另一些被交换出去，从而可以检查线程间交替行为的可预测性
### 资源管理的测试
### 使用回调
### 产生更多的交替操作
## 性能测试
### 增加计时功能
### 多种算法的比较
### 响应性衡量
## 避免性能测试的陷阱
### 垃圾回收
### 动态编译
### 对代码路径的不真实采样
### 不真实的竞争程度
### 无用代码的消除
要编写有效的性能测试程序，就需要告诉优化器不要将基准测试当做无用代码而优化掉。这就要求在程序中对每个计算结果都要通过某种方式来使用，这种方式不需要同步或者大量的计算。比如，在测试代码后加入“System.out.print('')”
## 其他的测试方法
### 代码审查
### 静态分析工具
静态分析工具能检查出的常见的错误模式：
- 不一致的同步
- 调用Thread.run()
- 未被释放的锁
- 空的同步块
- 双重检查加锁
- 在构造函数中启动一个线程
- 通知错误
- 条件等待中的错误
- 对Lock和Condition的误用
- 在休眠或等待的同时持有一个锁
- 自旋循环
### 面向切面的测试技术
### 分析与监测工具
## 小结
要测试并发程序的正确性可能非常困难，因为并发程序的许多故障模式都是一些低概率事件，他们对于执行的时序、负载情况以及其他难以重现的条件都非常敏感。而且，在测试程序中还会引入额外的同步或执行时序限制，这些因素将掩盖被测试代码中的一些并发问题。要测试并发程序的性能同样非常困难，与使用静态编译语言（例如C）编写的程序相比，用Java便携盒的程序在测试起来更加困难，因为动态编译、垃圾回收以及自动优化等操作都会影响与时间相关的测试结果。
要想尽可能的发现潜在的错误以及避免它们在正式产品中暴露出来，我们需要将传统的测试技术（要谨慎的避免在这里讨论的各种陷阱）与代码审查和自动化分析工具结合起来，每项技术都可以找出其他技术忽略的问题。
# 第十三章 显式锁
## Lock与ReentrantLock
### 轮询锁与定时锁
### 可中断的锁获取方式
### 非块结构的加锁
## 性能考虑因素
性能是一个不断变化的指标，如果在昨天的测试基准中发现X比Y更快，那么在今天可能已经过时了。
## 公平性
## 在synchronized和ReentrantLock之间进行选择
在一些内置所无法满足需求的情况下，ReentrantLock可以作为一种高级工具。当需要一些高级的功能时才应该使用ReentrantLock，这些功能包括：可定时的、可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。否则，还是应该优先使用synchronized。
## 读-写锁
交互方式：
- 释放优先
- 读线程插队
- 重入性
- 降级
- 升级
## 小结
与内置锁相比，显示的Lock提供了一些扩展功能，在处理锁的不可用性方面有着更高的灵活性，并且对队列行有着更好的控制。但ReentrantLock不能完全代替synchronized，只有在synchronized无法满足需求时，才应该使用它。
读-写锁允许多个新厂并发的访问被保护的对象，当访问以读取为主的数据结构时，它能提高程序的可伸缩性。
# 第十四章 构建自定义的同步工具
## 状态依赖的管理
### 条件队列
## 使用条件队列
### 条件谓词 
#### 将与条件队列相关的条件谓词以及在这些条件谓词上等待的操作都写入文档
#### 每一次wait调用都会隐式的与特定的条件谓词关联起来。当调用某个特定的条件谓词的wait时，调用者必须已经持有与调节队列相关的锁，并且这个锁必须保护着构成条件谓词的状态变量
### 过早唤醒
当使用条件等待时：
- 通常都有一个条件谓词——包括一些对象状态的测试，线程在执行前必须首先通过这些测试
- 在调用wait之前测试条件谓词，并且从wait中返回时再次进行测试
- 在一个循环中调用wait
- 确保使用与条件队列相关的锁来保护构成条件谓词的各个状态变量
- 当调用wait、notify、notifyAll等方法时，一定要持有与条件队列相关的锁
- 在检查条件谓词之后以及开始执行相应的操作之前，不要释放锁
### 丢失的信号
### 通知
#### 每当在等待一个条件时，一定要确保在条件谓词变为真实通过某种方式发出通知
只有同时满足一下两个条件时，才能用单一的notify而不是notifyAll：
- **所有等待线程的类型都相同**。只要一个条件谓词与条件队列相关，并且每个线程在从wait返回后将执行相同的操作。
- **单进单出**。在条件变量上的每次通知，最多只能唤醒一个线程来执行。
### 子类的安全问题
### 封装条件队列
### 入口协议与出口协议
## 显式的Condition对象
特别注意：在Condition对象中，与wait、notify和notifyAll方法对应的分别是await，signal，signalAll。但是，Condition对Object进行了扩展，因而它也会包含wait和notify方法。一定要使用正确的版本——await和signal。
## Synchronizer剖析
## AbstractQueuedSynchronizer
## java.util.concurrent同步器类中的AQS
### ReentrantLock
### Semaphore与CountDownLatch
### FutureTask
### ReentrantReadWriteLock
## 小结
要实现一个依赖状态的类——如果没有满足依赖状态的前提条件，那么这个类的方法必须阻塞，那么最好的方式是基于现有的库来构建，例如Semaphore.BlockingQueue或CountDownLatch，如第八章的ValueLatch所示。然而，有时候现有的库类不能提供足够的功能，在这种情况下，可以使用内置的条件队列，显示的Condition对象或者AQS来构建自己的同步器。内置条件队列与内置锁是紧密绑定在一起的，这是因为管理状态依赖性的机制必须与确保状态一致性的机制关联起来。同样，显式的COndition与显式的Lock也是紧密的绑定到一起的，并且与内置条件队列相比，还提供了一个扩展的功能集，包括每个所对应于多个等待线程集，可中断或不可中断的条件等待，公平或非公平的队列操作，以及基于时限的等待。
# 第十五章 原子变量与非阻塞同步机制
## 锁的劣势
- 挂起和恢复开销大
- 上下文切换在持有锁时间短的情况下开销相对较大
- 线程等待锁时不能处理其他事情
- 优先级反转和永久阻塞等
## 硬件对并发的支持
### 比较并交换（CAS）
### 非阻塞的计数器
### JVM对CAS的支持
## 原子变量类
### 原子变量是一种更好的“volatile”
### 性能比较：锁与原子变量
## 非阻塞算法
### 非阻塞的栈
### 非阻塞的链表
### 原子的域更新器
### ABA问题
## 小结
非阻塞算法通过底层的并发原语（例如比较并交换而不是锁）来维持线程的安全性。这些底层的原语通过原子变量向外公开，这些类也用做一种“更好的volatile”变量，从而为整数和对象引用提供原子的更新操作。
非阻塞算法在设计和实现时非常困难，但通常能够提供更高的可伸缩性，并能更好的防止活跃性故障的发生。在JVM从一个版本升级到下一个版本的过程中，并发性能的主要提升都来自于（在JVM内部以及平台类库中）对非阻塞算法的使用。
# 第十六章 Java内存模型
## 什么是内存模型，为什么需要它
### 平台的内存模型
### 重排序
### Java内存模型简介
Happens-Before的规则包括：
- **程序顺序规则**。如果程序中操作A在操作B之前，那么在线程中A操作将在B操作之前执行
- **监视器锁规则**。在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行
- **volatile变量规则**。对volatile变量的写入操作必须在对该变量的读操作之前执行
- **线程启动规则**。在线程上对Thread.start的调用必须在该线程中执行任何操作之前执行
- **线程结束规则**。线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行。或者从Thread.join中成功返回，或者在调用Thread.isAlive时返回false
- **中断规则**。当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt调用之前执行（通过抛出InterruptedException，或者调用isInterrupted和interrupted）
- **终结器规则**。对象的构造函数必须在启动该对象的终结器之前执行完成
- **传递性**。如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行
### 借助同步
## 发布
### 不安全的发布
除了不可变的对象以外，使用被另一个线程初始化的对象通常都是不安全的，除非对象的发布操作是在使用该对象的线程开始使用之前执行。
### 安全的发布
### 安全的初始化模式
### 双重检查加锁
## 初始化过程中的安全性
#### 初始化安全性将确保，对于被正确构造的对象，所有线程都能看到由构造函数为对象给各个final域设置的正确值，而不管采用何种方式来发布对象。而且，对于可以通过被正确构造对象中某个final域到达的任意变量（例如某个final数组中的元素，或者由一个final域引用的HasMap的内容）将同样对于其他线程是可见的。
#### 初始化安全性只能保证通过final域可达的值从构造过程完成时开始的可见性。对于通过非final域可达的值，或者在构造过程完成后可能改变的值，必须采用同步来确保可见性
## 小结
Java内存模型说明了某个线程的内存操作在哪些情况下对于其他线程是可见的。其中包括确保这些操作是按照一种Happens-Before的偏序关系进行排序，而这种关系是基于内存操作和同步操作等级别来定义的。如果缺少足够的同步，那么当线程访问共享数据时，会发生一些非常奇怪的问题。然而，如果是有第二章与第三章介绍的更高级规则，例如@grandedBy和安全发布，那么及时不考虑Happens-Before的底层细节，也能确保线程安全性。




